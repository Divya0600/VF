import tkinter as tk
from tkinter import filedialog, simpledialog, messagebox, ttk
import fitz  # PyMuPDF
import json
import os
from PIL import Image, ImageTk
import numpy as np

class PDFFieldMapper:
    def __init__(self, root):
        self.root = root
        self.root.title("PDF Field Mapper")
        self.root.geometry("1200x800")
        
        # State variables
        self.pdf_document = None
        self.current_page = 0
        self.current_page_image = None
        self.scale_factor = 1.0
        self.field_data = {}
        self.current_field_name = None
        self.current_field_prefix = None
        self.current_field_type = "character"  # Default field type
        self.selected_positions = []
        self.config_data = {
            "name": "Form Configuration",
            "description": "Generated by PDF Field Mapper",
            "empty_form_file": "",
            "output_file": "output/filled_form.pdf",
            "temp_overlay_file": "temp_overlay.pdf",
            "font_size": 10,
            "font_path": "fonts/AdobeClean-SemiLight.ttf",
            "default_letter_spacing": 13,
            "field_config": {},
            "field_coordinates": {}
        }
        
        # Create main frame
        self.main_frame = tk.Frame(self.root)
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create sidebar for controls
        self.sidebar = tk.Frame(self.main_frame, width=250, bg="#f0f0f0", relief=tk.RAISED, borderwidth=1)
        self.sidebar.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)
        
        # Create PDF display canvas with scrollbars
        self.canvas_frame = tk.Frame(self.main_frame)
        self.canvas_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.canvas = tk.Canvas(self.canvas_frame, bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.h_scrollbar = tk.Scrollbar(self.canvas_frame, orient=tk.HORIZONTAL, command=self.canvas.xview)
        self.v_scrollbar = tk.Scrollbar(self.canvas_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        
        self.canvas.config(xscrollcommand=self.h_scrollbar.set, yscrollcommand=self.v_scrollbar.set)
        
        self.h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        self.v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Status bar
        self.status_bar = tk.Label(self.root, text="Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Add sidebar controls
        self.create_sidebar_controls()
        
        # Bind canvas events
        self.canvas.bind("<Button-1>", self.on_canvas_click)
        self.canvas.bind("<B1-Motion>", self.on_canvas_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_canvas_release)
        
        # Mouse position tracking
        self.canvas.bind("<Motion>", self.on_mouse_move)
        
    def create_sidebar_controls(self):
        # Load PDF button
        load_btn = tk.Button(self.sidebar, text="Load PDF", command=self.load_pdf)
        load_btn.pack(fill=tk.X, padx=5, pady=5)
        
        # Page navigation
        page_frame = tk.Frame(self.sidebar)
        page_frame.pack(fill=tk.X, padx=5, pady=5)
        
        prev_btn = tk.Button(page_frame, text="←", command=self.prev_page)
        prev_btn.pack(side=tk.LEFT)
        
        self.page_label = tk.Label(page_frame, text="Page: 0/0")
        self.page_label.pack(side=tk.LEFT, padx=5)
        
        next_btn = tk.Button(page_frame, text="→", command=self.next_page)
        next_btn.pack(side=tk.LEFT)
        
        # Zoom controls
        zoom_frame = tk.Frame(self.sidebar)
        zoom_frame.pack(fill=tk.X, padx=5, pady=5)
        
        zoom_out_btn = tk.Button(zoom_frame, text="-", command=self.zoom_out)
        zoom_out_btn.pack(side=tk.LEFT)
        
        self.zoom_label = tk.Label(zoom_frame, text="100%")
        self.zoom_label.pack(side=tk.LEFT, padx=5)
        
        zoom_in_btn = tk.Button(zoom_frame, text="+", command=self.zoom_in)
        zoom_in_btn.pack(side=tk.LEFT)
        
        # Separator
        ttk.Separator(self.sidebar, orient='horizontal').pack(fill=tk.X, padx=5, pady=10)
        
        # Field configuration section
        tk.Label(self.sidebar, text="Field Configuration", font=("Arial", 10, "bold")).pack(anchor=tk.W, padx=5)
        
        # Field name entry
        field_frame = tk.Frame(self.sidebar)
        field_frame.pack(fill=tk.X, padx=5, pady=5)
        
        tk.Label(field_frame, text="Field Name:").pack(anchor=tk.W)
        self.field_name_entry = tk.Entry(field_frame)
        self.field_name_entry.pack(fill=tk.X, pady=2)
        
        # Field prefix entry
        tk.Label(field_frame, text="Field Prefix (optional):").pack(anchor=tk.W)
        self.field_prefix_entry = tk.Entry(field_frame)
        self.field_prefix_entry.pack(fill=tk.X, pady=2)
        
        # Field type selection
        tk.Label(field_frame, text="Field Type:").pack(anchor=tk.W)
        field_types = ["character", "checkbox", "date", "exact_key"]
        self.field_type_var = tk.StringVar(value=field_types[0])
        field_type_dropdown = ttk.Combobox(field_frame, textvariable=self.field_type_var, values=field_types)
        field_type_dropdown.pack(fill=tk.X, pady=2)
        
        # Start selection button
        start_btn = tk.Button(self.sidebar, text="Start Field Selection", command=self.start_field_selection)
        start_btn.pack(fill=tk.X, padx=5, pady=5)
        
        # Clear current selection
        clear_btn = tk.Button(self.sidebar, text="Clear Selection", command=self.clear_selection)
        clear_btn.pack(fill=tk.X, padx=5, pady=5)
        
        # Selected fields listbox
        tk.Label(self.sidebar, text="Selected Fields:", font=("Arial", 10, "bold")).pack(anchor=tk.W, padx=5, pady=5)
        
        self.fields_listbox = tk.Listbox(self.sidebar, height=10)
        self.fields_listbox.pack(fill=tk.X, padx=5, pady=5)
        
        # Remove selected field button
        remove_btn = tk.Button(self.sidebar, text="Remove Selected Field", command=self.remove_field)
        remove_btn.pack(fill=tk.X, padx=5, pady=5)
        
        # Save configuration button
        save_btn = tk.Button(self.sidebar, text="Save Configuration", command=self.save_configuration)
        save_btn.pack(fill=tk.X, padx=5, pady=5)
        
    def load_pdf(self):
        file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
        if not file_path:
            return
        
        try:
            self.pdf_document = fitz.open(file_path)
            self.current_page = 0
            
            # Update configuration with file path
            self.config_data["empty_form_file"] = file_path
            self.config_data["name"] = os.path.basename(file_path).split('.')[0]
            
            # Update page info
            self.page_label.config(text=f"Page: 1/{self.pdf_document.page_count}")
            
            # Display first page
            self.display_current_page()
            
            self.status_bar.config(text=f"Loaded PDF: {file_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load PDF: {e}")
    
    def display_current_page(self):
        if self.pdf_document is None:
            return
        
        # Get the page
        page = self.pdf_document[self.current_page]
        
        # Render the page to an image
        pix = page.get_pixmap(matrix=fitz.Matrix(self.scale_factor, self.scale_factor))
        
        # Convert to PIL Image
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        self.current_page_image = ImageTk.PhotoImage(image=img)
        
        # Update canvas
        self.canvas.config(scrollregion=(0, 0, pix.width, pix.height))
        self.canvas.create_image(0, 0, image=self.current_page_image, anchor=tk.NW, tags="page")
        
        # Redraw any selections
        self.redraw_selections()
        
        # Update page label
        self.page_label.config(text=f"Page: {self.current_page + 1}/{self.pdf_document.page_count}")
    
    def redraw_selections(self):
        # Clear existing rectangles
        self.canvas.delete("selection")
        
        # Draw all fields from config_data
        for field_name, coords in self.config_data["field_coordinates"].items():
            if coords["page"] == self.current_page:
                x0, y0 = coords["x0"] * self.scale_factor, coords["y0"] * self.scale_factor
                x1, y1 = coords["x1"] * self.scale_factor, coords["y1"] * self.scale_factor
                self.canvas.create_rectangle(x0, y0, x1, y1, outline="blue", tags="selection")
                self.canvas.create_text((x0 + x1) / 2, y0 - 10, text=field_name, fill="blue", tags="selection")
        
        # Draw current selection
        if self.selected_positions:
            for pos in self.selected_positions:
                if pos["page"] == self.current_page:
                    x0, y0 = pos["x0"] * self.scale_factor, pos["y0"] * self.scale_factor
                    x1, y1 = pos["x1"] * self.scale_factor, pos["y1"] * self.scale_factor
                    self.canvas.create_rectangle(x0, y0, x1, y1, outline="red", tags="selection")
    
    def next_page(self):
        if self.pdf_document and self.current_page < self.pdf_document.page_count - 1:
            self.current_page += 1
            self.display_current_page()
    
    def prev_page(self):
        if self.pdf_document and self.current_page > 0:
            self.current_page -= 1
            self.display_current_page()
    
    def zoom_in(self):
        self.scale_factor *= 1.2
        self.zoom_label.config(text=f"{int(self.scale_factor * 100)}%")
        self.display_current_page()
    
    def zoom_out(self):
        self.scale_factor /= 1.2
        self.zoom_label.config(text=f"{int(self.scale_factor * 100)}%")
        self.display_current_page()
    
    def on_mouse_move(self, event):
        # Get canvas coordinates
        canvas_x = self.canvas.canvasx(event.x)
        canvas_y = self.canvas.canvasy(event.y)
        
        # Convert to PDF coordinates
        pdf_x = canvas_x / self.scale_factor
        pdf_y = canvas_y / self.scale_factor
        
        self.status_bar.config(text=f"Position: ({pdf_x:.2f}, {pdf_y:.2f})")
    
    def start_field_selection(self):
        # Get field name and type
        field_name = self.field_name_entry.get().strip()
        field_prefix = self.field_prefix_entry.get().strip()
        field_type = self.field_type_var.get()
        
        if not field_name:
            messagebox.showerror("Error", "Please enter a field name")
            return
        
        self.current_field_name = field_name
        self.current_field_prefix = field_prefix
        self.current_field_type = field_type
        self.selected_positions = []
        
        self.status_bar.config(text=f"Click and drag to select positions for field: {field_name}")
    
    def on_canvas_click(self, event):
        if not self.current_field_name:
            return
        
        # Get canvas coordinates
        canvas_x = self.canvas.canvasx(event.x)
        canvas_y = self.canvas.canvasy(event.y)
        
        # Store start position
        self.start_x = canvas_x
        self.start_y = canvas_y
        
        # Create temporary rectangle
        self.current_rect = self.canvas.create_rectangle(
            canvas_x, canvas_y, canvas_x, canvas_y, 
            outline="red", tags="temp_selection"
        )
    
    def on_canvas_drag(self, event):
        if not hasattr(self, 'current_rect'):
            return
            
        # Get canvas coordinates
        canvas_x = self.canvas.canvasx(event.x)
        canvas_y = self.canvas.canvasy(event.y)
        
        # Update rectangle
        self.canvas.coords(self.current_rect, self.start_x, self.start_y, canvas_x, canvas_y)
    
    def on_canvas_release(self, event):
        if not hasattr(self, 'current_rect') or not self.current_field_name:
            return
            
        # Get canvas coordinates
        canvas_x = self.canvas.canvasx(event.x)
        canvas_y = self.canvas.canvasy(event.y)
        
        # Ensure correct order (x0 <= x1, y0 <= y1)
        x0 = min(self.start_x, canvas_x) / self.scale_factor
        y0 = min(self.start_y, canvas_y) / self.scale_factor
        x1 = max(self.start_x, canvas_x) / self.scale_factor
        y1 = max(self.start_y, canvas_y) / self.scale_factor
        
        # Store position
        position = {
            "x0": x0,
            "y0": y0,
            "x1": x1,
            "y1": y1,
            "page": self.current_page
        }
        
        # For character fields, create individual character cells
        if self.current_field_type == "character":
            # Ask how many characters to create
            char_count = simpledialog.askinteger("Character Count", "How many characters?", minvalue=1, maxvalue=100)
            if char_count:
                width = (x1 - x0) / char_count
                for i in range(char_count):
                    char_x0 = x0 + i * width
                    char_x1 = x0 + (i + 1) * width
                    
                    # Create field name based on character index
                    if self.current_field_prefix:
                        field_key = f"{self.current_field_prefix}_{chr(65 + i)}"  # A, B, C, ...
                    else:
                        field_key = f"{self.current_field_name}_{chr(65 + i)}"
                    
                    # Add to configuration
                    self.config_data["field_coordinates"][field_key] = {
                        "x0": char_x0,
                        "y0": y0,
                        "x1": char_x1,
                        "y1": y1,
                        "page": self.current_page
                    }
                    
                # Add field configuration
                if self.current_field_prefix:
                    self.config_data["field_config"][self.current_field_name] = {
                        "prefix": self.current_field_prefix + "_"
                    }
                else:
                    # Use a default prefix based on field name
                    self.config_data["field_config"][self.current_field_name] = {
                        "prefix": self.current_field_name + "_"
                    }
        elif self.current_field_type == "exact_key":
            # For exact key fields, just add the field as is
            field_key = self.current_field_name
            self.config_data["field_coordinates"][field_key] = position
            self.config_data["field_config"][self.current_field_name] = {
                "exact_key": field_key
            }
        else:
            # For other field types, add with the current name
            field_key = self.current_field_name
            self.config_data["field_coordinates"][field_key] = position
            
            # Add field configuration based on type
            if self.current_field_type == "checkbox":
                self.config_data["field_config"][self.current_field_name] = {
                    "exact_key": field_key
                }
        
        # Update fields listbox
        self.update_fields_listbox()
        
        # Clean up
        self.canvas.delete("temp_selection")
        del self.current_rect
        
        # Redraw all selections
        self.redraw_selections()
        
        self.status_bar.config(text=f"Added field: {self.current_field_name}")
    
    def update_fields_listbox(self):
        # Clear and refill the listbox
        self.fields_listbox.delete(0, tk.END)
        
        # Populate with field names
        for field_name in self.config_data["field_config"].keys():
            self.fields_listbox.insert(tk.END, field_name)
    
    def clear_selection(self):
        if hasattr(self, 'current_rect'):
            self.canvas.delete("temp_selection")
            del self.current_rect
        
        self.selected_positions = []
        self.status_bar.config(text="Selection cleared")
    
    def remove_field(self):
        # Get selected field from listbox
        selection = self.fields_listbox.curselection()
        if not selection:
            messagebox.showerror("Error", "Please select a field to remove")
            return
        
        field_name = self.fields_listbox.get(selection[0])
        
        # Remove from field_config
        if field_name in self.config_data["field_config"]:
            del self.config_data["field_config"][field_name]
        
        # Remove associated coordinates
        # For prefix-based fields, remove all matching keys
        keys_to_remove = []
        for key in self.config_data["field_coordinates"].keys():
            # Check if key matches exact field name
            if key == field_name:
                keys_to_remove.append(key)
            # Check if field uses a prefix and key starts with that prefix
            elif field_name in self.config_data["field_config"] and \
                 "prefix" in self.config_data["field_config"][field_name] and \
                 key.startswith(self.config_data["field_config"][field_name]["prefix"]):
                keys_to_remove.append(key)
        
        for key in keys_to_remove:
            del self.config_data["field_coordinates"][key]
        
        # Update listbox and redraw
        self.update_fields_listbox()
        self.redraw_selections()
        
        self.status_bar.config(text=f"Removed field: {field_name}")
    
    def save_configuration(self):
        if not self.pdf_document:
            messagebox.showerror("Error", "No PDF loaded")
            return
        
        file_path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json")],
            initialdir="forms_config"
        )
        
        if not file_path:
            return
        
        try:
            with open(file_path, 'w') as f:
                json.dump(self.config_data, f, indent=2)
            
            self.status_bar.config(text=f"Configuration saved to: {file_path}")
            messagebox.showinfo("Success", f"Configuration saved to: {file_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save configuration: {e}")

if __name__ == "__main__":
    # Create required directories
    for directory in ["forms_config", "forms", "output", "fonts"]:
        if not os.path.exists(directory):
            os.makedirs(directory)
    
    root = tk.Tk()
    app = PDFFieldMapper(root)
    root.mainloop()